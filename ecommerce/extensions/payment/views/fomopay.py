"""FOMO Pay payment processing views."""

import base64
import logging
import StringIO

import qrcode
import requests
from django.core.exceptions import ObjectDoesNotExist
from django.db import transaction
from django.shortcuts import redirect, render
from django.urls import reverse
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import View
from oscar.apps.partner import strategy
from oscar.apps.payment.exceptions import GatewayError, PaymentError, TransactionDeclined, UserCancelled
from oscar.core.loading import get_class, get_model

from ecommerce.extensions.checkout.mixins import EdxOrderPlacementMixin
from ecommerce.extensions.payment.exceptions import (
    AuthorizationError,
    DuplicateReferenceNumber,
    InvalidBasketError,
    InvalidSignatureError
)
from ecommerce.extensions.payment.processors.fomopay import Fomopay

logger = logging.getLogger(__name__)

Applicator = get_class('offer.applicator', 'Applicator')
Basket = get_model('basket', 'Basket')
OrderNumberGenerator = get_class('order.utils', 'OrderNumberGenerator')


class FomopayQRView(View):
    """Starts FOMO Pay payment process.

    This view acts as an interface between the user and FOMO Pay,
    it'll mainly display the QR code and instructions on how to make a payment with the WeChat app.
    """

    # Disable CSRF validation. The internal POST requests to render this view
    # don't include the CSRF token as hosted-side payment processor are
    # excepted to be externally hosted, but this is not the case.
    # Instead of changing the checkout flow for all the payment processors
    # this view is marked as exempt.
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super(FomopayQRView, self).dispatch(request, *args, **kwargs)

    def post(self, request):
        """ Render QR Code.

        Process the incoming request to render the QR in the template.
        """
        qr_url = self._get_qr_link(request)
        qr_img = self._generate_qr(qr_url)
        context = {'qrcode': qr_img}

        return render(request, 'payment/fomopay.html', context)

    def _generate_qr(self, qr_url):
        """
        Create a base64 representation of the QR code image.
        """
        img = qrcode.make(qr_url)
        img_io = StringIO.StringIO()
        img.save(img_io, format='PNG')

        return base64.b64encode(img_io.getvalue())

    def _get_qr_link(self, request):
        """
        Process the outgoing request to the FOMO API to obtain the
        link needed to create the QR code
        """
        params = request.POST.dict()
        api_url = params.pop('api_url')
        response = requests.post(url=api_url, data=params)
        fomo_response = response.json()
        qr_url = fomo_response.get('url')

        return qr_url


class FomopayPaymentResponseView(EdxOrderPlacementMixin, View):
    """ Starts FOMO Pay payment process.

    This view is intended to be called asynchronously by the payment processor.
    The view expects POST data containing a transaction ID and the payment result
    to complete the fulfillment pipeline.
    """

    # Disable atomicity for the view. Otherwise, we'd be unable to commit to the database
    # until the request had concluded; Django will refuse to commit when an atomic() block
    # is active, since that would break atomicity. Without an order present in the database
    # at the time fulfillment is attempted, asynchronous order fulfillment tasks will fail.
    @method_decorator(transaction.non_atomic_requests)
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super(FomopayPaymentResponseView, self).dispatch(request, *args, **kwargs)

    @property
    def payment_processor(self):
        return Fomopay(self.request.site)

    def post(self, request):
        """
        Process a FOMO Pay merchant notification and place an order for paid products as appropriate.
        """
        try:
            notification = request.POST.dict()
            basket = self.validate_notification(notification)

        except:  # pylint: disable=bare-except
            return redirect(reverse('payment_error'))

    def validate_notification(self, notification):
        """
        Process the incoming notification to verify origin's authenticity and transaction result.
        """
        # Note (CCB): Orders should not be created until the payment processor has validated the response's signature.
        # This validation is performed in the handle_payment method. After that method succeeds, the response can be
        # safely assumed to have originated from FOMO Pay.
        basket = None
        transaction_id = None

        try:
            # The transaction id refers to the ID generated by FOMO Pay
            transaction_id = notification.get('payment_id')
            # FOMO Pay uses the transaction field as the reference code or order number
            order_number = notification.get('transaction')
            basket_id = OrderNumberGenerator().basket_id(order_number)

            logger.info(
                'Received FOMO Pay payment notification for payment id [%s], associated with basket [%d].',
                transaction_id,
                basket_id
            )

            basket = self._get_basket(basket_id)

            if not basket:
                logger.error('Received FOMO Pay payment notification for non-existent basket [%s].', basket_id)
                raise InvalidBasketError

            if basket.status != Basket.FROZEN:
                # We don't know how serious this situation is at this point, hence
                # the INFO level logging. This notification is most likely FOMO Pay
                # telling us that they've declined an attempt to pay for an existing order.
                logger.info(
                    'Received FOMO Pay payment notification for basket [%d] which is in a non-frozen state, [%s]',
                    basket.id, basket.status
                )
        finally:
            # Store the response in the database regardless of its authenticity.
            ppr = self.payment_processor.record_processor_response(
                notification, transaction_id=transaction_id, basket=basket
            )

        # Explicitly delimit operations which will be rolled back if an exception occurs.
        with transaction.atomic():
            try:
                self.handle_payment(notification, basket)
            except InvalidSignatureError:
                logger.exception(
                    'Received an invalid FOMO Pay response. The payment response was recorded in entry [%d].',
                    ppr.id
                )
                raise
            except (UserCancelled, TransactionDeclined) as exception:
                logger.info(
                    'FOMO Pay payment [%d] did not complete for basket [%d] because [%s]. '
                    'The payment response [%s] was recorded in entry [%d].',
                    basket.id,
                    exception.__class__.__name__,
                    notification.get("result", "Unknown Error"),
                    ppr.id
                )
                raise
            except DuplicateReferenceNumber:
                logger.info(
                    'Received FOMO Pay payment notification for basket [%d] which is associated '
                    'with existing order [%s]. No payment was collected, and no new order will be created.',
                    basket.id,
                    order_number
                )
                raise
            except AuthorizationError:
                logger.info(
                    'Payment Authorization was declined for basket [%d]. The payment response was '
                    'recorded in entry [%d].',
                    basket.id,
                    ppr.id,
                )
            except PaymentError:
                logger.exception(
                    'FOMO Pay payment failed for basket [%d]. The payment response [%s] was recorded in entry [%d].',
                    basket.id,
                    notification.get("result", "Unknown Error"),
                    ppr.id
                )
                raise
            except:  # pylint: disable=bare-except
                logger.exception(
                    'Attempts to handle payment for basket [%d] failed. The payment response [%s] was recorded in'
                    ' entry [%d].',
                    basket.id,
                    notification.get("result", "Unknown Error"),
                    ppr.id
                )
                raise

        return basket

    def _get_basket(self, basket_id):
        """Return basket object from the basket_id."""
        if not basket_id:
            return None

        try:
            basket_id = int(basket_id)
            basket = Basket.objects.get(id=basket_id)
            basket.strategy = strategy.Default()
            Applicator().apply(basket, basket.owner, self.request)
            return basket
        except (ValueError, ObjectDoesNotExist):
            return None
